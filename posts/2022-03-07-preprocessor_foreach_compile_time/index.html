<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">

  <title>erenon.hu</title>
  <meta name="description" content="Short thoughts on C++, Unix and in general, technology">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://erenon.hu/">
  <link rel="alternate" type="application/rss+xml" title="erenon.hu" href="http://erenon.hu/posts/index.xml">
</head>
<body>
  <header class="site-header">
  <div class="wrapper">
    <a class="site-title" href="/">erenon.hu</a>
  </div>
  </header>

  <div class="page-content">
    <div class="wrapper">

<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Preprocessor foreach compile time</h1><time class="post-meta" datetime="2022-03-07">2022-03-07</time>
  </header>
  <div class="post-content" itemprop="articleBody"><p>Assume you want to create a preprocessor macro that takes a macro <code>F</code>
and a variable number of arguments. When expanded, it invokes <code>F</code> with each argument:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define FOREACH(F, ...) </span><span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nf">FOREACH</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="c1">// expands to: G(a) G(b) G(c)
</span></span></span></code></pre></div><p>Such a macro can be useful for example for a log library.
There are several ways to implement it.
Here, we compare three different implementations,
with regard to complexity, ease of change, and compile time.</p>
<p>The complete source code used for testing is available at <a href="https://github.com/erenon/pp-foreach-comparison">erenon/pp-foreach-comparison</a>.</p>
<h2 id="contenders">Contenders</h2>
<p>The first implementation is taken from <strong><a href="http://binlog.org">binlog</a></strong>.
It consists of a macro that counts the number of arguments,
and <code>N</code> foreach macros, one for each arity.
It is generated by a python script, <code>binlog.py</code>.
<code>N</code> is a parameter of the generator script, here, <code>N=512</code>.
This version is slightly different from the original one used in binlog,
to match the capabilities of the other contenders, for a fair comparison.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">sys</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">N</span> <span class="o">=</span> <span class="mi">512</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;#define CAT(a, b) CAT_I(a, b)&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;#define CAT_I(a, b) a ## b&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;#define COUNT(...) COUNT_I(__VA_ARGS__&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;,</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;#define COUNT_I(&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;a</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">,&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;...) a</span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;#define FOREACH(F, ...) CAT(FOREACH_, COUNT(__VA_ARGS__)) (F, __VA_ARGS__)&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;#define FOREACH_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">(F&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;,a</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; F(a</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&#34;</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>For <code>N=3</code>, it looks like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define CAT(a, b) CAT_I(a, b)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define CAT_I(a, b) a ## b
</span></span></span><span class="line"><span class="cl"><span class="cp">#define COUNT(...) COUNT_I(__VA_ARGS__,2,1,0)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define COUNT_I(a1,a2,a3,...) a3
</span></span></span><span class="line"><span class="cl"><span class="cp">#define FOREACH(F, ...) CAT(FOREACH_, COUNT(__VA_ARGS__)) (F, __VA_ARGS__)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define FOREACH_1(F,a0) F(a0)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define FOREACH_2(F,a0,a1) F(a0) F(a1)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define FOREACH_3(F,a0,a1,a2) F(a0) F(a1) F(a2)
</span></span></span></code></pre></div><p><em>Disclaimer</em>: I&rsquo;m the author of binlog.</p>
<p>The second implementation is taken from <strong><a href="https://github.com/swansontec/map-macro">swansontec</a></strong>.
It is a complex, but documented solution.
It works with up to <code>N=364</code> arguments. The idea can be expanded to
support more arguments. The entry point of the solution
is renamed to <code>FOREACH</code> in the snippet below:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/* Created by William Swanson in 2012. Public Domain. */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#define EVAL0(...) __VA_ARGS__
</span></span></span><span class="line"><span class="cl"><span class="cp">#define EVAL1(...) EVAL0(EVAL0(EVAL0(__VA_ARGS__)))
</span></span></span><span class="line"><span class="cl"><span class="cp">#define EVAL2(...) EVAL1(EVAL1(EVAL1(__VA_ARGS__)))
</span></span></span><span class="line"><span class="cl"><span class="cp">#define EVAL3(...) EVAL2(EVAL2(EVAL2(__VA_ARGS__)))
</span></span></span><span class="line"><span class="cl"><span class="cp">#define EVAL4(...) EVAL3(EVAL3(EVAL3(__VA_ARGS__)))
</span></span></span><span class="line"><span class="cl"><span class="cp">#define EVAL(...)  EVAL4(EVAL4(EVAL4(__VA_ARGS__)))
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define MAP_END(...)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MAP_OUT
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MAP_COMMA ,
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define MAP_GET_END2() 0, MAP_END
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MAP_GET_END1(...) MAP_GET_END2
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MAP_GET_END(...) MAP_GET_END1
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MAP_NEXT0(test, next, ...) next MAP_OUT
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MAP_NEXT1(test, next) MAP_NEXT0(test, next, 0)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MAP_NEXT(test, next)  MAP_NEXT1(MAP_GET_END test, next)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define MAP0(f, x, peek, ...) f(x) MAP_NEXT(peek, MAP1)(f, peek, __VA_ARGS__)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MAP1(f, x, peek, ...) f(x) MAP_NEXT(peek, MAP0)(f, peek, __VA_ARGS__)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define MAP_LIST_NEXT1(test, next) MAP_NEXT0(test, MAP_COMMA next, 0)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MAP_LIST_NEXT(test, next)  MAP_LIST_NEXT1(MAP_GET_END test, next)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define MAP_LIST0(f, x, peek, ...) f(x) MAP_LIST_NEXT(peek, MAP_LIST1)(f, peek, __VA_ARGS__)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MAP_LIST1(f, x, peek, ...) f(x) MAP_LIST_NEXT(peek, MAP_LIST0)(f, peek, __VA_ARGS__)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Applies the function macro `f` to each of the remaining parameters.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define FOREACH(f, ...) EVAL(MAP1(f, __VA_ARGS__, ()()(), ()()(), ()()(), 0))
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Applies the function macro `f` to each of the remaining parameters and
</span></span></span><span class="line"><span class="cl"><span class="cm"> * inserts commas between the results.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define MAP_LIST(f, ...) EVAL(MAP_LIST1(f, __VA_ARGS__, ()()(), ()()(), ()()(), 0))
</span></span></span></code></pre></div><p>The third implementation is taken from <strong><a href="https://github.com/morganstanley/hobbes/">hobbes</a></strong>.
It is a complex solution.
It works with up to <code>N=513</code> arguments, probably it can be changed
to support more. The entry point of the solution
is renamed to <code>FOREACH</code> in the snippet below:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Copyright 2016 Morgan Stanley
</span></span></span><span class="line"><span class="cl"><span class="c1">// Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at
</span></span></span><span class="line"><span class="cl"><span class="c1">// http://www.apache.org/licenses/LICENSE-2.0
</span></span></span><span class="line"><span class="cl"><span class="c1">// https://github.com/morganstanley/hobbes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define HOBPP_FIRST(a, ...) a
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_SECOND(a, b, ...) b
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_CAT(a,b) a ## b
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_IS_PROBE(...) HOBPP_SECOND(__VA_ARGS__, 0)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_PROBE() ~, 1
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_NOT(x) HOBPP_IS_PROBE(HOBPP_CAT(HOBPP_SNOT_, x))
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_SNOT_0 HOBPP_PROBE()
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_BOOL(x) HOBPP_NOT(HOBPP_NOT(x))
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_IF_ELSE(condition) HOBPP_SIF_ELSE(HOBPP_BOOL(condition))
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_SIF_ELSE(condition) HOBPP_CAT(HOBPP_SIF_, condition)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_SIF_1(...) __VA_ARGS__ HOBPP_SIF_1_ELSE
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_SIF_0(...)             HOBPP_SIF_0_ELSE
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_SIF_1_ELSE(...)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_SIF_0_ELSE(...) __VA_ARGS__
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_EMPTY()
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_EVAL(...) HOBPP_EVAL256(__VA_ARGS__)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_EVAL256(...) HOBPP_EVAL128(HOBPP_EVAL128(__VA_ARGS__))
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_EVAL128(...) HOBPP_EVAL64(HOBPP_EVAL64(__VA_ARGS__))
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_EVAL64(...) HOBPP_EVAL32(HOBPP_EVAL32(__VA_ARGS__))
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_EVAL32(...) HOBPP_EVAL16(HOBPP_EVAL16(__VA_ARGS__))
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_EVAL16(...) HOBPP_EVAL8(HOBPP_EVAL8(__VA_ARGS__))
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_EVAL8(...) HOBPP_EVAL4(HOBPP_EVAL4(__VA_ARGS__))
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_EVAL4(...) HOBPP_EVAL2(HOBPP_EVAL2(__VA_ARGS__))
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_EVAL2(...) HOBPP_EVAL1(HOBPP_EVAL1(__VA_ARGS__))
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_EVAL1(...) __VA_ARGS__
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_DEFER2(m) m HOBPP_EMPTY HOBPP_EMPTY()()
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_HAS_PARGS(...) HOBPP_BOOL(HOBPP_FIRST(HOBPP_SEOAP_ __VA_ARGS__)())
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_SEOAP_(...) HOBPP_BOOL(HOBPP_FIRST(HOBPP_SEOA_ __VA_ARGS__)())
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_SEOA_() 0
</span></span></span><span class="line"><span class="cl"><span class="cp">#define FOREACH(f, VS...) HOBPP_EVAL(HOBPP_MAPP(f, VS))
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_MAPP(f, H, T...)        \
</span></span></span><span class="line"><span class="cl"><span class="cp">  f(H)                                \
</span></span></span><span class="line"><span class="cl"><span class="cp">  HOBPP_IF_ELSE(HOBPP_HAS_PARGS(T))(  \
</span></span></span><span class="line"><span class="cl"><span class="cp">    HOBPP_DEFER2(HOBPP_SMAPP)()(f, T) \
</span></span></span><span class="line"><span class="cl"><span class="cp">  )(                                  \
</span></span></span><span class="line"><span class="cl"><span class="cp">  )
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HOBPP_SMAPP() HOBPP_MAPP
</span></span></span></code></pre></div><h2 id="compile-time-comparison">Compile Time Comparison</h2>
<p>To measure the time it takes to preprocess a solution,
for each solution, a source file is generated, that includes the implementation,
and invokes <code>FOREACH</code> with <code>M</code> arguments, 32 times. Then the time the compiler spends
in user space, while preprocessing the file is measured.
Finally, measured time is plotted against the number of arguments:</p>
<p><figure>
  <img src="/img/gcc.svg" alt="Plot showing how much time different solutions take to preprocess with gcc, as the number of arguments increases">
  <figcaption></figcaption>
</figure>

<figure>
  <img src="/img/clang.svg" alt="Plot showing how much time different solutions take to preprocess with clang, as the number of arguments increases">
  <figcaption></figcaption>
</figure>
</p>
<p>The measurement was done using gcc 11.1.0 and clang 13.0.0, on Linux 5.16,
running on a x86_64 AMD machine.
From the plots we can infer that:</p>
<ul>
<li>
<p>Preprocessing binlog takes a small, constant amount of time,
regardless the number of <code>FOREACH</code> arguments.</p>
</li>
<li>
<p>The preprocessing time of swansontec and hobbes linearly
increases as the number of arguments increases. The hobbes solution
is roughly two times slower than swansontec.</p>
</li>
<li>
<p>There is no meaningful case where swansontec or hobbes would be faster than binlog.</p>
</li>
<li>
<p>clang is almost three times slower to preprocess these files, than gcc.</p>
</li>
</ul>
<h2 id="implementation-comparison">Implementation Comparison</h2>
<p>The three solutions are also different implementation wise.
I&rsquo;m giving here a comparison along a mix of subjective and objective axes:</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:center">binlog</th>
<th style="text-align:center">swansontec</th>
<th style="text-align:center">hobbes</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Complexity</td>
<td style="text-align:center">low</td>
<td style="text-align:center">high</td>
<td style="text-align:center">high</td>
</tr>
<tr>
<td style="text-align:left">Extensibility</td>
<td style="text-align:center">easy</td>
<td style="text-align:center">difficult</td>
<td style="text-align:center">difficult</td>
</tr>
<tr>
<td style="text-align:left">Documentation</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:left">File Size (N&lt;=512)</td>
<td style="text-align:center">1.6 MB</td>
<td style="text-align:center">2 kB</td>
<td style="text-align:center">2 kB</td>
</tr>
<tr>
<td style="text-align:left">Generated Code</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:left">License</td>
<td style="text-align:center">Apache 2</td>
<td style="text-align:center">Public Domain</td>
<td style="text-align:center">Apache 2</td>
</tr>
</tbody>
</table>
<p>By <em>Complexity</em>, I mean the effort required to understand and verify the correctness of the implementation.
By <em>Extensibility</em>, I mean the effort required to change the behavior of the implementation,
e.g: support 0 arguments, pass along a constant data value, increase <code>N</code>, inject a token between <code>F</code> calls, etc.</p>
<h2 id="verdict">Verdict</h2>
<p>Interestingly, less code doesn&rsquo;t mean faster to compile (preprocess) code.
Despite that the generated source code of the binlog solution is almost a 1000 times bigger,
it is still favourable compile time performance wise.
Furthermore, the straightforward, simple solution is easier to understand and modify.
Therefore, if code generation or having large source files is not an issue,
I see no reason to use a more complicated solution.</p>

  </div>
</article>


    </div>
  </div>

  <footer class="site-footer">
  <div class="wrapper">
    <div class="footer-col-wrapper">
      
      <div class="footer-col footer-col-3">
        <ul class="social-media-list">
          
          <li>
            Previous post: <a class="prev" href="http://erenon.hu/posts/2022-02-21-snapcast-on-demand/">Snapcast on Demand</a>
          </li>
          
          
          <li>
            Next post: <a class="next" href="http://erenon.hu/posts/2022-03-30-shared-static-storage/">Static storage shared between compilation units</a>
          </li>
          
        </ul>
      </div>
      
      <div class="footer-col footer-col-1">
        <ul class="social-media-list">
          <li>
            <a href="/posts/index.xml">RSS</a>
          </li>
          <li>
            <a href="https://github.com/erenon" class="username">GitHub</a>
          </li>
          <li>
            <a href="https://stackoverflow.com/users/116273" class="username">StackOverflow</a>
          </li>
        </ul>
      </div>
    </div>
  </div>
  </footer>
</body>
</html>
